{
  "name": "Real-Time Meta Ads Alerts",
  "nodes": [
    {
      "parameters": {
        "rule": {
          "interval": [
            {
              "field": "hours",
              "hoursInterval": 2
            }
          ]
        }
      },
      "name": "Every 2 Hours Schedule",
      "type": "n8n-nodes-base.cron",
      "typeVersion": 1,
      "position": [
        240,
        300
      ]
    },
    {
      "parameters": {
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "metaAdsApi",
        "resource": "adAccount",
        "operation": "getAll",
        "limit": 25
      },
      "name": "Get All Ad Accounts",
      "type": "n8n-nodes-base.metaAds",
      "typeVersion": 1,
      "position": [
        460,
        300
      ]
    },
    {
      "parameters": {
        "functionCode": "// Process account list for parallel monitoring\nconst allAccountsData = [];\n\n// Process each ad account\nfor (const account of $input.all()) {\n  const accountId = account.json.id;\n  const accountName = account.json.name;\n  \n  // Store account info for parallel processing\n  allAccountsData.push({\n    id: accountId,\n    name: accountName,\n    originalData: account.json\n  });\n}\n\n// Return account data for parallel processing\nreturn allAccountsData.map(account => ({ json: account }));"
      },
      "name": "Process Account List",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [
        680,
        300
      ]
    },
    {
      "parameters": {
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "metaAdsApi",
        "resource": "insights",
        "operation": "get",
        "adAccountId": "={{$json.id}}",
        "level": "campaign",
        "timeRange": "today",
        "fields": [
          "campaign_id",
          "campaign_name",
          "spend",
          "impressions",
          "clicks",
          "actions",
          "cost_per_action_type",
          "date_start",
          "date_stop"
        ]
      },
      "name": "Get Today's Insights",
      "type": "n8n-nodes-base.metaAds",
      "typeVersion": 1,
      "position": [
        900,
        300
      ]
    },
    {
      "parameters": {
        "functionCode": "// Import required modules\nconst MetaDataProcessor = require('./lib/meta-data-processor');\nconst config = require('./config/thresholds');\nconst processor = new MetaDataProcessor();\n\n// Get all input data\nconst allData = $input.all();\n\n// Group data by account\nconst groupedData = {};\nconst criticalIssues = [];\n\nfor (const item of allData) {\n  const accountId = item.json.account_id || item.json.id;\n  const accountName = item.json.account_name || item.json.name;\n  \n  if (!groupedData[accountId]) {\n    groupedData[accountId] = {\n      id: accountId,\n      name: accountName,\n      campaigns: []\n    };\n  }\n  \n  // Add campaign data\n  if (item.json.data) {\n    groupedData[accountId].campaigns = item.json.data;\n  }\n}\n\n// Process each account for critical issues\nfor (const [accountId, accountData] of Object.entries(groupedData)) {\n  try {\n    // Process campaigns\n    const processedCampaigns = processor.processCampaigns(accountData.campaigns);\n    \n    // Find critical campaigns\n    const criticalCampaigns = processedCampaigns.filter(campaign => \n      campaign.severity === 'critical' && campaign.spend >= config.thresholds.minimumSpend\n    );\n    \n    // Add to critical issues if found\n    if (criticalCampaigns.length > 0) {\n      criticalIssues.push({\n        accountId: accountId,\n        accountName: accountData.name,\n        criticalCampaigns: criticalCampaigns,\n        timestamp: new Date().toISOString()\n      });\n    }\n  } catch (error) {\n    console.error(`Error processing account ${accountId}:`, error);\n  }\n}\n\n// Return critical issues for alert processing\nif (criticalIssues.length > 0) {\n  return criticalIssues.map(issue => ({ json: issue }));\n} else {\n  // No critical issues found\n  return [{\n    json: {\n      noCriticalIssues: true,\n      timestamp: new Date().toISOString(),\n      accountsChecked: Object.keys(groupedData).length,\n      message: 'No critical issues detected'\n    }\n  }];\n}"
      },
      "name": "Analyze for Critical Issues",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [
        1120,
        300
      ]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "leftValue": "={{$json.noCriticalIssues}}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equal"
              }
            }
          ],
          "combinator": "and"
        }
      },
      "name": "Check If Critical Issues Found",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        1340,
        300
      ]
    },
    {
      "parameters": {
        "functionCode": "// Generate AI crisis analysis for critical issues\nconst AIAnalyzer = require('./lib/ai-analyzer');\nconst config = require('./config/thresholds');\n\n// Initialize AI analyzer\nconst aiAnalyzer = new AIAnalyzer(config.openai.apiKey);\n\n// Get critical issue data\nconst criticalData = $input.first().json;\nconst { accountName, criticalCampaigns } = criticalData;\n\n// Generate crisis analysis\nlet crisisAnalysis;\ntry {\n  crisisAnalysis = await aiAnalyzer.generateCrisisAnalysis(criticalCampaigns, {\n    accountName: accountName,\n    timestamp: new Date().toISOString()\n  });\n} catch (error) {\n  console.error('Crisis analysis failed:', error);\n  // Use fallback analysis\n  crisisAnalysis = {\n    emergencyActions: [\n      'Pause campaigns with CPL > Â£40',\n      'Review targeting immediately',\n      'Check budget allocation'\n    ],\n    quickWins: [\n      'Update ad creative',\n      'Adjust audience targeting',\n      'Review landing page'\n    ],\n    rootCause: 'High competition or poor targeting likely causing issues',\n    nextSteps: [\n      'Analyze competitor activity',\n      'Review audience insights',\n      'Test new creative approaches'\n    ],\n    timestamp: new Date().toISOString()\n  };\n}\n\n// Return data with crisis analysis\nreturn [{\n  json: {\n    ...criticalData,\n    crisisAnalysis: crisisAnalysis\n  }\n}];"
      },
      "name": "Generate Crisis Analysis",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [
        1560,
        200
      ]
    },
    {
      "parameters": {
        "functionCode": "// Import report formatter\nconst ReportFormatter = require('./lib/report-formatter');\nconst formatter = new ReportFormatter();\n\n// Get crisis data\nconst crisisData = $input.first().json;\n\n// Format alert notification\nconst alertNotification = formatter.formatAlert(crisisData);\n\n// Return formatted alert\nreturn [{\n  json: {\n    ...crisisData,\n    alertNotification: alertNotification\n  }\n}];"
      },
      "name": "Format Alert Notification",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [
        1780,
        200
      ]
    },
    {
      "parameters": {
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "smtp",
        "fromEmail": "={{$json.alertNotification.email.from || 'alerts@meta-ads-automation.com'}}",
        "toEmail": "={{$json.alertNotification.email.to || 'sam@atlas-gyms.co.uk'}}",
        "subject": "={{$json.alertNotification.email.subject}}",
        "emailType": "html",
        "message": "={{$json.alertNotification.email.html}}",
        "ccEmail": "={{$json.alertNotification.email.cc || ''}}",
        "bccEmail": "={{$json.alertNotification.email.bcc || ''}}"
      },
      "name": "Send Alert Email",
      "type": "n8n-nodes-base.emailSend",
      "typeVersion": 1,
      "position": [
        2000,
        100
      ]
    },
    {
      "parameters": {
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "telegramApi",
        "resource": "message",
        "operation": "sendMessage",
        "chatId": "={{$env.TELEGRAM_CHAT_ID}}",
        "text": "={{$json.alertNotification.telegram}}",
        "parseMode": "Markdown"
      },
      "name": "Send Telegram Alert",
      "type": "n8n-nodes-base.telegram",
      "typeVersion": 1,
      "position": [
        2000,
        300
      ]
    },
    {
      "parameters": {
        "functionCode": "// Check alert cooldown to prevent spam\nconst fs = require('fs');\nconst path = require('path');\n\n// Get alert data\nconst alertData = $input.first().json;\nconst { accountId, criticalCampaigns } = alertData;\n\n// Create cooldown tracking directory\nconst cooldownDir = './storage/alert-cooldowns';\nif (!fs.existsSync(cooldownDir)) {\n  fs.mkdirSync(cooldownDir, { recursive: true });\n}\n\n// Check cooldown for each campaign\nconst config = require('./config/thresholds');\nconst cooldownMinutes = config.alerts.alertCooldown || 30;\nconst now = new Date();\n\nconst allowedCampaigns = [];\n\nfor (const campaign of criticalCampaigns) {\n  const cooldownFile = path.join(cooldownDir, `${campaign.campaignId}.json`);\n  \n  try {\n    if (fs.existsSync(cooldownFile)) {\n      const cooldownData = JSON.parse(fs.readFileSync(cooldownFile, 'utf8'));\n      const lastAlert = new Date(cooldownData.lastAlert);\n      const timeSinceLastAlert = (now - lastAlert) / (1000 * 60); // minutes\n      \n      if (timeSinceLastAlert >= cooldownMinutes) {\n        allowedCampaigns.push(campaign);\n        // Update cooldown file\n        fs.writeFileSync(cooldownFile, JSON.stringify({\n          campaignId: campaign.campaignId,\n          lastAlert: now.toISOString(),\n          alertCount: (cooldownData.alertCount || 0) + 1\n        }));\n      }\n    } else {\n      // First alert for this campaign\n      allowedCampaigns.push(campaign);\n      fs.writeFileSync(cooldownFile, JSON.stringify({\n        campaignId: campaign.campaignId,\n        lastAlert: now.toISOString(),\n        alertCount: 1\n      }));\n    }\n  } catch (error) {\n    console.error(`Error checking cooldown for campaign ${campaign.campaignId}:`, error);\n    // Allow alert on error\n    allowedCampaigns.push(campaign);\n  }\n}\n\n// Return data with filtered campaigns\nif (allowedCampaigns.length > 0) {\n  return [{\n    json: {\n      ...alertData,\n      criticalCampaigns: allowedCampaigns,\n      originalCount: criticalCampaigns.length,\n      allowedCount: allowedCampaigns.length\n    }\n  }];\n} else {\n  // All campaigns are in cooldown\n  return [{\n    json: {\n      ...alertData,\n      allInCooldown: true,\n      message: 'All campaigns are in alert cooldown period'\n    }\n  }];\n}"
      },
      "name": "Check Alert Cooldown",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [
        1560,
        400
      ]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "leftValue": "={{$json.allInCooldown}}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equal"
              }
            }
          ],
          "combinator": "and"
        }
      },
      "name": "Check If Alerts Allowed",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        1780,
        400
      ]
    },
    {
      "parameters": {
        "functionCode": "// Log alert activity and store for historical tracking\nconst fs = require('fs');\nconst path = require('path');\n\n// Get alert data\nconst alertData = $input.first().json;\n\n// Create alerts log directory\nconst alertsDir = './storage/alerts';\nif (!fs.existsSync(alertsDir)) {\n  fs.mkdirSync(alertsDir, { recursive: true });\n}\n\n// Generate alert log entry\nconst alertLogEntry = {\n  timestamp: new Date().toISOString(),\n  accountId: alertData.accountId,\n  accountName: alertData.accountName,\n  criticalCampaigns: alertData.criticalCampaigns.map(c => ({\n    campaignId: c.campaignId,\n    campaignName: c.campaignName,\n    costPerLead: c.costPerLead,\n    spend: c.spend,\n    leads: c.leads,\n    issues: c.issues\n  })),\n  crisisAnalysis: alertData.crisisAnalysis,\n  alertType: 'critical_performance'\n};\n\n// Save alert log\nconst today = new Date().toISOString().split('T')[0];\nconst alertLogFile = path.join(alertsDir, `alerts-${today}.json`);\n\ntry {\n  let alertLog = [];\n  if (fs.existsSync(alertLogFile)) {\n    alertLog = JSON.parse(fs.readFileSync(alertLogFile, 'utf8'));\n  }\n  \n  alertLog.push(alertLogEntry);\n  fs.writeFileSync(alertLogFile, JSON.stringify(alertLog, null, 2));\n  \n  console.log(`Alert logged: ${alertData.accountName} - ${alertData.criticalCampaigns.length} campaigns`);\n} catch (error) {\n  console.error('Error logging alert:', error);\n}\n\n// Return success status\nreturn [{\n  json: {\n    success: true,\n    message: 'Alert sent successfully',\n    timestamp: new Date().toISOString(),\n    accountName: alertData.accountName,\n    criticalCampaigns: alertData.criticalCampaigns.length,\n    alertsSent: {\n      email: true,\n      telegram: true\n    }\n  }\n}];"
      },
      "name": "Log Alert Activity",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [
        2220,
        200
      ]
    },
    {
      "parameters": {
        "functionCode": "// Log successful monitoring run without alerts\nconst monitoringData = $input.first().json;\n\nconsole.log(`Real-time monitoring completed: ${monitoringData.accountsChecked} accounts checked, no critical issues found`);\n\n// Return status\nreturn [{\n  json: {\n    success: true,\n    message: 'Monitoring completed - no critical issues',\n    timestamp: new Date().toISOString(),\n    accountsChecked: monitoringData.accountsChecked,\n    criticalIssues: 0\n  }\n}];"
      },
      "name": "Log No Issues",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [
        1560,
        500
      ]
    },
    {
      "parameters": {
        "functionCode": "// Log campaigns in cooldown\nconst cooldownData = $input.first().json;\n\nconsole.log(`Campaigns in cooldown: ${cooldownData.accountName} - ${cooldownData.originalCount} issues found, ${cooldownData.allowedCount} alerts allowed`);\n\n// Return status\nreturn [{\n  json: {\n    success: true,\n    message: 'Campaigns in alert cooldown',\n    timestamp: new Date().toISOString(),\n    accountName: cooldownData.accountName,\n    campaignsInCooldown: cooldownData.originalCount - cooldownData.allowedCount\n  }\n}];"
      },
      "name": "Log Cooldown Status",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [
        2000,
        500
      ]
    },
    {
      "parameters": {
        "functionCode": "// Error handling for real-time monitoring\nconst error = $input.first().json.error;\nconst context = $input.first().json.context || 'Real-time monitoring';\n\nconsole.error(`Real-time monitoring error in ${context}:`, error);\n\n// Send error notification\nconst errorMessage = `ð¨ *Real-Time Monitoring Error*\\n\\nContext: ${context}\\nError: ${error.message || error}\\n\\nTime: ${new Date().toLocaleString('en-GB')}\\n\\n_Next check in 2 hours_`;\n\nreturn [{\n  json: {\n    chatId: process.env.TELEGRAM_CHAT_ID,\n    text: errorMessage,\n    parseMode: 'Markdown'\n  }\n}];"
      },
      "name": "Error Handler",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [
        1340,
        600
      ]
    },
    {
      "parameters": {
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "telegramApi",
        "resource": "message",
        "operation": "sendMessage",
        "chatId": "={{$json.chatId}}",
        "text": "={{$json.text}}",
        "parseMode": "={{$json.parseMode}}"
      },
      "name": "Send Error Alert",
      "type": "n8n-nodes-base.telegram",
      "typeVersion": 1,
      "position": [
        1560,
        600
      ]
    },
    {
      "parameters": {
        "functionCode": "// Rate limiting check to prevent too many alerts\nconst fs = require('fs');\nconst path = require('path');\n\n// Get alert data\nconst alertData = $input.first().json;\n\n// Create rate limiting directory\nconst rateLimitDir = './storage/rate-limits';\nif (!fs.existsSync(rateLimitDir)) {\n  fs.mkdirSync(rateLimitDir, { recursive: true });\n}\n\n// Check hourly rate limit\nconst config = require('./config/thresholds');\nconst maxAlertsPerHour = config.alerts.maxAlertsPerHour || 10;\nconst now = new Date();\nconst currentHour = now.getHours();\nconst today = now.toISOString().split('T')[0];\n\nconst rateLimitFile = path.join(rateLimitDir, `rate-limit-${today}.json`);\n\ntry {\n  let rateLimitData = {};\n  if (fs.existsSync(rateLimitFile)) {\n    rateLimitData = JSON.parse(fs.readFileSync(rateLimitFile, 'utf8'));\n  }\n  \n  const hourKey = `hour_${currentHour}`;\n  const alertsThisHour = rateLimitData[hourKey] || 0;\n  \n  if (alertsThisHour >= maxAlertsPerHour) {\n    // Rate limit exceeded\n    return [{\n      json: {\n        ...alertData,\n        rateLimitExceeded: true,\n        message: `Rate limit exceeded: ${alertsThisHour}/${maxAlertsPerHour} alerts sent this hour`\n      }\n    }];\n  } else {\n    // Update rate limit counter\n    rateLimitData[hourKey] = alertsThisHour + 1;\n    fs.writeFileSync(rateLimitFile, JSON.stringify(rateLimitData, null, 2));\n    \n    // Allow alert\n    return [{\n      json: {\n        ...alertData,\n        rateLimitOk: true,\n        alertsThisHour: alertsThisHour + 1\n      }\n    }];\n  }\n} catch (error) {\n  console.error('Error checking rate limit:', error);\n  // Allow alert on error\n  return [{\n    json: {\n      ...alertData,\n      rateLimitOk: true,\n      rateLimitError: true\n    }\n  }];\n}"
      },
      "name": "Check Rate Limit",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [
        1340,
        200
      ]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "leftValue": "={{$json.rateLimitExceeded}}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equal"
              }
            }
          ],
          "combinator": "and"
        }
      },
      "name": "Check Rate Limit Status",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        1560,
        100
      ]
    },
    {
      "parameters": {
        "functionCode": "// Log rate limit exceeded\nconst rateLimitData = $input.first().json;\n\nconsole.log(`Rate limit exceeded: ${rateLimitData.message}`);\n\n// Send rate limit notification once per hour\nconst rateLimitMessage = `â ï¸ *Alert Rate Limit Exceeded*\\n\\n${rateLimitData.message}\\n\\nCritical alerts are being throttled to prevent spam.\\n\\nTime: ${new Date().toLocaleString('en-GB')}`;\n\nreturn [{\n  json: {\n    chatId: process.env.TELEGRAM_CHAT_ID,\n    text: rateLimitMessage,\n    parseMode: 'Markdown'\n  }\n}];"
      },
      "name": "Log Rate Limit",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [
        1780,
        100
      ]
    },
    {
      "parameters": {
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "telegramApi",
        "resource": "message",
        "operation": "sendMessage",
        "chatId": "={{$json.chatId}}",
        "text": "={{$json.text}}",
        "parseMode": "={{$json.parseMode}}"
      },
      "name": "Send Rate Limit Alert",
      "type": "n8n-nodes-base.telegram",
      "typeVersion": 1,
      "position": [
        2000,
        100
      ]
    }
  ],
  "connections": {
    "Every 2 Hours Schedule": {
      "main": [
        [
          {
            "node": "Get All Ad Accounts",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get All Ad Accounts": {
      "main": [
        [
          {
            "node": "Process Account List",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Process Account List": {
      "main": [
        [
          {
            "node": "Get Today's Insights",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Today's Insights": {
      "main": [
        [
          {
            "node": "Analyze for Critical Issues",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Analyze for Critical Issues": {
      "main": [
        [
          {
            "node": "Check If Critical Issues Found",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check If Critical Issues Found": {
      "main": [
        [
          {
            "node": "Log No Issues",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Check Rate Limit",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check Rate Limit": {
      "main": [
        [
          {
            "node": "Check Rate Limit Status",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check Rate Limit Status": {
      "main": [
        [
          {
            "node": "Log Rate Limit",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Generate Crisis Analysis",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Generate Crisis Analysis": {
      "main": [
        [
          {
            "node": "Format Alert Notification",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Format Alert Notification": {
      "main": [
        [
          {
            "node": "Check Alert Cooldown",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check Alert Cooldown": {
      "main": [
        [
          {
            "node": "Check If Alerts Allowed",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check If Alerts Allowed": {
      "main": [
        [
          {
            "node": "Log Cooldown Status",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Send Alert Email",
            "type": "main",
            "index": 0
          },
          {
            "node": "Send Telegram Alert",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Send Alert Email": {
      "main": [
        [
          {
            "node": "Log Alert Activity",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Send Telegram Alert": {
      "main": [
        [
          {
            "node": "Log Alert Activity",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Error Handler": {
      "main": [
        [
          {
            "node": "Send Error Alert",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Log Rate Limit": {
      "main": [
        [
          {
            "node": "Send Rate Limit Alert",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": true,
  "settings": {
    "executionOrder": "v1",
    "saveManualExecutions": true,
    "callerPolicy": "workflowsFromSameOwner",
    "errorWorkflow": "Error Handler"
  },
  "staticData": {},
  "meta": {
    "templateCredsSetupCompleted": true
  },
  "tags": [
    {
      "createdAt": "2025-07-15T10:00:00.000Z",
      "updatedAt": "2025-07-15T10:00:00.000Z",
      "id": "2",
      "name": "Meta Ads Automation"
    }
  ]
}